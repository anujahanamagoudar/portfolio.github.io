<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City Design</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Poppins', sans-serif;
            background-color: #dfffd6; /* Light green background */
            color: #333;
        }
        /* Navigation Bar Styles */
        nav {
            background-color: #27ae60; /* Green background */
            padding: 10px 20px;
            text-align: center;
        }
        nav a {
            color: white;
            font-size: 18px;
            margin: 0 15px;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        nav a:hover {
            background-color: #2ecc71; /* Lighter green on hover */
        }

        /* Personal Information Section */
        .personal-info {
            background-color: #fff;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 80%;
            border-radius: 10px;
        }
        .personal-info h1 {
            color: #27ae60;
            font-size: 28px;
            margin: 0;
        }
        .personal-info p {
            font-size: 16px;
            color: #333;
            line-height: 1.6;
        }
        .personal-info a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }

        /* Center Bar and Content Section Styles */
        .center-bar {
            background-color: #fff; /* White bar */
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 80%;
            border-radius: 10px;
        }
        .center-bar h1 {
            font-size: 28px;
            color: #27ae60;
            margin: 0;
        }
        .center-bar h2 {
            font-size: 22px;
            color: #27ae60;
            margin: 5px 0 0;
        }
        .content {
            padding: 20px;
        }
        .content-section {
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .content-section h1 {
            font-size: 28px;
            color: #27ae60;
            margin-bottom: 10px;
        }
        .content-section h2 {
            font-size: 22px;
            color: #27ae60;
            margin-top: 0;
        }
        .content-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .content-box {
            flex: 1 1 45%;
            padding: 20px;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
        }
        .content-box h2 {
            font-size: 22px;
            color: #27ae60;
            margin-bottom: 10px;
        }
        .content-box p {
            font-size: 16px;
            color: #333;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav>
        <a href="#my-portfolio">My Portfolio</a>
        <a href="#home">Home</a>
        <a href="#course-project">Course Project Introduction</a>
        <a href="#business-cases">Business Cases</a> <!-- New navigation item -->
    </nav>

    <!-- Personal Information Section -->
    <div id="my-portfolio" class="personal-info">
        <h1>Anuja Hanamagoudar</h1>
        <p>Welcome to my portfolio! I am passionate about technology and problem-solving.</p>

        <h2>üõ† Projects</h2>
        <p><strong>Project 1:</strong> Smart City Rajpur is an ambitious urban development project aimed at transforming Rajpur into a modern, sustainable, and technology-driven city. The initiative focuses on improving infrastructure, including smart traffic management, efficient waste disposal systems, and reliable public transportation. With the integration of IoT (Internet of Things) technology, the city seeks to enhance the quality of life for its residents by providing better healthcare, education, and safety services. Renewable energy solutions, green spaces, and eco-friendly practices are central to the vision, ensuring that Rajpur becomes an environmentally sustainable and future-ready urban space.</p>

        <h2>üöÄ Skills</h2>
        <p>C, C++ <br> Data Structures and Algorithms</p>

        <h2>üåê Find Me Online</h2>
        <p><a href="https://github.com/yourusername" target="_blank">GitHub</a></p>

        <h2>Portfolio Topic</h2>
        <p><strong>Course Name:</strong> Algorithmic Problem Solving <br> <strong>Course Code:</strong> 24ECSC205</p>

        <h2>Instructor & University</h2>
        <p><strong>Instructor:</strong> Arundhati Aralimatti <br> <strong>University:</strong> KLE Technological University, Hubballi</p>

        <h2>Portfolio Topic/Domain</h2>
        <p>Google</p>

        <h2>Inspirational Quote</h2>
        <p>‚ÄúThe only way to do great work is to love what you do.‚Äù ‚Äì Steve Jobs</p>
    </div>

    <!-- Home Section -->
    <div id="home" class="center-bar">
        <h1>RAJPUR</h1>
        <h2>WELCOME TO OUR TEAM PORTFOLIO ON SMART CITY PROJECT</h2>
    </div>

    <div class="content">
        <div class="content-section" id="course-introduction">
            <h1>COURSE INTRODUCTION</h1>
            <h2>What is the course about?</h2>
            <p>The Design and Analysis of Algorithms course is all about developing a deep understanding of how algorithms work, how they are designed, and how they can be optimized for efficiency.</p>
            <div class="content-row">
                <div class="content-box">
                    <h2>What is the course about?</h2>
                    <p>The Design and Analysis of Algorithms course is all about developing a deep understanding of how algorithms work, how they are designed, and how they can be optimized for efficiency. This course emphasizes:</p>
                    <p>- The systematic design of algorithms.<br>- The analysis of their time and space complexities.<br>- The application of mathematical tools to compare algorithm performance.</p>
                    <p>By studying this, I have gained the skills to approach problems systematically, design solutions, and measure their efficiency.</p>
                </div>
            </div>
        </div>

        <div class="content-section" id="real-world-connection">
            <h1>CONNECTION WITH REAL WORLD</h1>
            <h2>What kind of data structures and algorithms have I studied?</h2>
            <p>During the course, I explored a variety of data structures and algorithms, including:</p>
            <p><strong>Data Structures:</strong> Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables.</p>
            <p><strong>Algorithms:</strong> Sorting algorithms like Merge Sort and Quick Sort, graph algorithms like Dijkstra‚Äôs and Kruskal‚Äôs, and advanced string matching algorithms like Rabin-Karp and Boyer-Moore.</p>
            <p>Each topic built upon the foundational knowledge, helping me to analyze problems from different perspectives and apply the most suitable data structure or algorithm.</p>
        </div>

        <div class="content-section" id="importance">
            <h1>Why is this course important?</h1>
            <p>This course is a stepping stone for anyone aspiring to excel in fields like software engineering, competitive programming, and machine learning. It lays the foundation for efficient problem-solving, a skill crucial in today‚Äôs fast-paced technological world. Through this learning portfolio, I aim to demonstrate my understanding and enthusiasm for algorithms and data structures, reflecting on how they shape the software and tools we use daily.</p>
        </div>

<div id="course-project" class="content-section">
    <h1>Course Project Introduction</h1>
    
    <h2>Problem Space:</h2>
    <p>Cities are growing rapidly, leading to challenges such as overcrowded roads, increased pollution, and inadequate basic resources like water and electricity. We need innovative solutions to address these issues and enhance urban living.</p>

    <h2>White Paper Findings:</h2>
    <p><strong>Simple Tech Solutions:</strong> Ideas like energy-efficient street lights, traffic management apps, and sensors for monitoring water usage.</p>
    <p><strong>Successful Cities:</strong> Cities like Copenhagen have adopted bicycles and solar panels to conserve energy and cut down on pollution.</p>
    <p><strong>Challenges:</strong> The high cost of implementing new systems and the lack of trust or knowledge in using technology remain significant obstacles.</p>

    <h2>City Design Recommendations:</h2>
    <ul>
        <li>Upgrade outdated infrastructure like roads, water pipes, and buildings.</li>
        <li>Implement basic tools such as traffic cameras and air quality sensors.</li>
        <li>Test new ideas in smaller neighborhoods before a broader rollout.</li>
        <li>Ensure accessibility and ease of use for all residents.</li>
        <li>Invest in quality education to empower the community with the necessary skills.</li>
    </ul>

    <h2>Problem Definition:</h2>
    <p>Develop a centralized system to streamline the management of university processes.</p>

    <h2>Business Cases Identified:</h2>
    <ul>
        <li>Student Admission Management</li>
        <li>Course Scheduling</li>
        <li>Faculty Recruitment and Management</li>
        <li>Students Performance Tracking</li>
        <li>Parking Management</li>
        <li>Feedback and Quality Assurance</li>
    </ul>

    <h2>Team Details:</h2>
    
    <h3 style="font-size: 24px;">Member 1:</h3>
<p style="font-size: 18px;">
    <strong>Name:</strong> Anuja Hanamagoudar<br>
    <img src="Proffesional_Photo.jpg" alt="Anuja Hanamagoudar" width="200" height="250"><br>
    <strong>Roll No:</strong> 442<br>
    <strong>USN:</strong> 01FE23BCS263<br>
    <strong>Division:</strong> D<br>
</p>

<h3 style="font-size: 24px;">Member 2:</h3>
<p style="font-size: 18px;">
    <strong>Name:</strong> Rashmi Khot<br>
    <img src="https://example.com/images/rashmi-photo.jpg" alt="Rashmi Khot" width="200" height="250"><br>
    <strong>Roll No:</strong> 58<br>
    <strong>USN:</strong> 01FE23BCS408<br>
    <strong>Division:</strong> D<br>
</p>

<h3 style="font-size: 24px;">Member 3:</h3>
<p style="font-size: 18px;">
    <strong>Name:</strong> Lata Rathod<br>
    <img src="https://example.com/images/lata-photo.jpg" alt="Lata Rathod" width="200" height="250"><br>
    <strong>Roll No:</strong> 459<br>
    <strong>USN:</strong> 01FE23BCS409<br>
    <strong>Division:</strong> D<br>
</p>

<h3 style="font-size: 24px;">Member 4:</h3>
<p style="font-size: 18px;">
    <strong>Name:</strong> Manasi Divate<br>
    <img src="https://example.com/images/manasi-photo.jpg" alt="Manasi Divate" width="200" height="250"><br>
    <strong>Roll No:</strong> 453<br>
    <strong>USN:</strong> 01FE23BCS403<br>
    <strong>Division:</strong> D<br>
</p>
</div>


        <!-- Business Cases Section -->
        <div id="business-cases" class="content-section">
        <h1>Business Cases</h1>
        
        <section>
            <h2>Problem Definition</h2>
            <p>To develop a centralized system to streamline the management of university processes.</p>
        </section>

        <section>
            <h2>Student Admission Management</h2>
            <p>The Student Admission Management System supports SDG 4 by ensuring inclusive and equitable access to quality education.</p>
            <p><strong>Target 4.7:</strong> Ensure learners acquire the knowledge and skills needed to promote sustainable development by 2030.</p>
            <p><strong>Indicator 4.7.1:</strong> Extent to which global citizenship education and education for sustainable development are mainstreamed in national policies and curricula.</p>
            <p><strong>Target 4.4:</strong> Increase the number of youth and adults with relevant skills for employment, decent jobs, and entrepreneurship by 2030.</p>
            <p><strong>Indicator 4.4.1:</strong> Proportion of youth and adults with ICT skills, by type of skill.</p>
        </section>

        <section>
            <h3>Reflections</h3>
            <h4>1. What are the kinds of problems we see in nature? (Iteration, Recursion, Backtracking)</h4>
            <p><strong>Iteration</strong></p>
            <ul>
                <li>Traveling to college every day (repeated routine)</li>
                <li>Playing the game of chess (turn-based sequences)</li>
                <li>Preparing for an assembly (step-by-step organization)</li>
                <li>The process of learning (daily practice and effort)</li>
                <li>Resource management at a wedding (iterative allocation of resources)</li>
            </ul>
            
            <p><strong>Recursion</strong></p>
            <ul>
                <li>The tree that has been growing every day (branches resembling the whole tree structure)</li>
                <li>The growth of cauliflower vegetables (fractal patterns)</li>
                <li>Matryoshka dolls (nested structure with self-similarity)</li>
                <li>A calendar (days, weeks, and months recur in predictable patterns)</li>
            </ul>
            
            <p><strong>Backtracking</strong></p>
            <ul>
                <li>Searching for a new friend‚Äôs location (exploring different paths or strategies)</li>
                <li>Solving Sudoku (backtracking to correct mistakes)</li>
                <li>The placement of objects (optimizing arrangements by trying alternatives)</li>
            </ul>
        </section>

        <section>
    <h2>2. What is Space and Time Efficiency? Why Are They Important?</h2>
    <h3>Algorithm Efficiency and Complexity</h3>
    <p><strong>Time Efficiency:</strong> Measures the computational time required to execute an algorithm and represents the number of basic operations performed by an algorithm.</p>
    <p><strong>Space Efficiency:</strong> Measures the memory (storage) required by an algorithm, tracking how much memory is consumed by the input size and determining how much additional memory is needed to solve a problem.</p>

    <h4>Key Principles:</h4>
    <ul>
        <li>A good algorithm executes quickly and saves space in the process.</li>
        <li>We should find a balance between space and time efficiency (space and time complexity).</li>
    </ul>

    <p>In the world of computer science, to perform better, we need to write algorithms that are time-efficient and use less memory. Algorithms should be resource-optimized, solving larger problems with limited computing power, and improving user experience and system performance.</p>

    <h4>Different Classes of Problems and Orders of Growth:</h4>
    <table border="1">
        <thead>
            <tr>
                <th>Order of Growth</th>
                <th>Performance Description</th>
                <th>Example Complexity</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>O(1) - Constant Time</td>
                <td>Performance is independent of input size.</td>
                <td>Accessing a specific element in an array</td>
            </tr>
            <tr>
                <td>O(log n) - Logarithmic Time</td>
                <td>Performance grows logarithmically with input size.</td>
                <td>Binary search</td>
            </tr>
            <tr>
                <td>O(n) - Linear Time</td>
                <td>Performance grows proportionally with input size.</td>
                <td>Linear search</td>
            </tr>
            <tr>
                <td>O(n<sup>2</sup>) - Quadratic Time</td>
                <td>Performance grows with the square of the input size.</td>
                <td>Bubble sort, insertion sort</td>
            </tr>
            <tr>
                <td>O(2<sup>n</sup>) - Exponential Time</td>
                <td>Performance doubles with each addition to the input size.</td>
                <td>Solving the Travelling Salesman Problem using brute force</td>
            </tr>
        </tbody>
    </table>
</section>


        <section>
            <h2>3. Takeaway from Different Design Principles from Chapter 2</h2>

            <p><strong>Decomposition:</strong> Break complex problems into smaller, manageable pieces to simplify and solve them effectively.</p>

            <p><strong>Pattern Recognition:</strong> Identify recurring patterns in problems to generalize solutions and make predictions.</p>

            <p><strong>Abstraction:</strong> Focus on essential features and ignore unnecessary details to simplify problem-solving.</p>

            <p><strong>Brave vs. Cautious Traversal:</strong>
                <ul>
                    <li><strong>DFS (Brave):</strong> Explore deeply before backtracking.</li>
                    <li><strong>BFS (Cautious):</strong> Explore level by level.</li>
                </ul>
            </p>

            <p><strong>Pruning:</strong> Skip unnecessary paths to save time and resources (e.g., N-Queen‚Äôs problem).</p>

            <p><strong>Lazy Propagation:</strong> Delay updates in data structures like segment trees for efficiency, especially with large datasets.</p>

            <p><strong>Sliding Window:</strong> Efficiently analyze overlapping sub-arrays, useful for tasks like finding maximum sums.</p>

            <p><strong>Level Order Traversal:</strong> Explore tree nodes level by level (similar to BFS).</p>

            <p><strong>Hierarchical Data:</strong> Use parent-child relationships (e.g., family trees) to organize and manage information.</p>

            <p><strong>Edge Relaxation:</strong> Update shortest paths in algorithms like Dijkstra‚Äôs by rechecking neighboring paths.</p>

            <p><strong>Balancing and Rotations:</strong> Prevent unbalanced trees in AVL and Red-Black trees to maintain efficient operations.</p>

            <p><strong>Kleene Closure:</strong> Find relationships in graphs and determine all possible connections (transitive closure).</p>

            <p><strong>Pre-Computing:</strong> Calculate and store frequently needed results in advance to save runtime (e.g., lookup tables).</p>

            <p><strong>Parental Dominance:</strong> Maintain efficiency in heaps by ensuring the root is the largest or smallest element.</p>

            <p><strong>Prefix and Suffix:</strong> Key for pattern matching and string operations in tasks like searching and bioinformatics.</p>

            <p><strong>Partitioning:</strong> Divide problems into smaller parts for recursion, widely used in sorting and searching.</p>

            <p><strong>Bit Manipulations:</strong> Use operations like AND, OR, XOR for memory-efficient algorithms (e.g., Fenwick trees).</p>

            <p><strong>Memoization:</strong> Store previous results in recursive algorithms to avoid redundant calculations.</p>

            <p><strong>Invariants:</strong> Conditions that stay constant during execution, ensuring correctness (e.g., maintaining sorted order).</p>

            <p><strong>Shortest Path Trees:</strong> Show shortest routes from a starting node, useful for navigation and network optimization.</p>
        </section>
            
    <section>
    <h4>4. Hierarchical data and how different tree data structures solve and optimize problems</h4>
    <table border='2'>
        <thead>
            <tr>
                <th>Tree Type</th>
                <th>Best For</th>
                <th>Strength</th>
                <th>Limitation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>BST</td>
                <td>Sorted data with moderate updates</td>
                <td>Simple structure</td>
                <td>Can become unbalanced</td>
            </tr>
            <tr>
                <td>AVL Tree</td>
                <td>Frequent lookups and moderate insertions/deletions</td>
                <td>Guarantees balance</td>
                <td>Costly rotations</td>
            </tr>
            <tr>
                <td>2-3 Tree</td>
                <td>Predictable performance in all operations</td>
                <td>Consistent height</td>
                <td>Complexity of implementation</td>
            </tr>
            <tr>
                <td>Red-Black Tree</td>
                <td>Dynamic datasets with frequent updates</td>
                <td>Fewer rotations than AVL</td>
                <td>Slightly less balanced than AVL</td>
            </tr>
            <tr>
                <td>Heap</td>
                <td>Priority-based operations</td>
                <td>Efficient min/max retrieval</td>
                <td>Not suited for general searching</td>
            </tr>
            <tr>
                <td>Trie</td>
                <td>String data and prefix-based operations</td>
                <td>Fast prefix search</td>
                <td>High memory usage for sparse data</td>
            </tr>
        </tbody>
    </table>
</section>




        <section>
            <h4>5. The need of array query algorithms and their implications</h4>
            <p><strong>Principles of Array Query Algorithms</strong></p>
            <ul>
                <li><strong>Divide and Conquer:</strong> Breaking queries into smaller subproblems for efficient computation.</li>
                <li><strong>Dynamic Programming:</strong> Storing intermediate results to avoid redundant calculations.</li>
                <li><strong>Optimization:</strong> Balancing preprocessing time with query time to achieve overall efficiency.</li>
            </ul>
            <p><strong>Array Query Algorithms: Overview</strong></p>
            <p><strong>Core Purpose:</strong> Array query algorithms are designed to efficiently retrieve, manipulate, or analyze information within large datasets, addressing challenges of:</p>
            <ul>
                <li>Fast information retrieval</li>
                <li>Complex data processing</li>
                <li>Minimizing computational complexity</li>
            </ul>
            <p><strong>Binary Search (Binary Index Tree):</strong></p>
            <ul>
                <li><strong>Principle:</strong> Divide and conquer strategy</li>
                <li><strong>Efficiency:</strong> O(log n)</li>
                <li><strong>Requirements:</strong> Sorted array</li>
                <li><strong>Applications:</strong> Used in large sorted databases</li>
            </ul>
            <p><strong>Sliding Window Technique:</strong></p>
            <ul>
                <li><strong>Principle:</strong> Maintain a window of elements</li>
                <li><strong>Efficiency:</strong> O(n)</li>
                <li><strong>Applications:</strong> Used in network traffic analysis and signal processing</li>
            </ul>
            <p><strong>Segment Tree:</strong></p>
            <ul>
                <li><strong>Principle:</strong> Divide array into segments</li>
                <li><strong>Efficiency:</strong> O(log n)</li>
                <li><strong>Applications:</strong> Range min/max queries</li>
            </ul>
        </section>

        <section>
            <h4>6. Trees and graphs and their traversals</h4>
            <p><strong>Differentiating Trees and Graphs:</strong></p>
            <ul>
                <li><strong>Tree:</strong> A simple structure with one main "root" and branches that don‚Äôt loop back (no cycles). It is like a family tree where each person has only one parent (except for the root). Example: A folder structure on your computer.</li>
                <li><strong>Graph:</strong> A graph is more complex. It can have cycles (loops) and no specific structure. Nodes (points) can be connected in many different ways, not necessarily hierarchically. Example: A map of cities connected by roads, where you can travel in multiple directions.</li>
            </ul>
            <p><strong>Tree Traversals (Ways to visit nodes in a tree):</strong></p>
            <ul>
                <li><strong>In-Order:</strong> Visit left side, then the node, then right side. Used for: Sorting data in binary search trees.</li>
                <li><strong>Pre-Order:</strong> Visit the node first, then the left side, and then the right side. Used for: Making a copy of the tree.</li>
                <li><strong>Post-Order:</strong> Visit the left side first, then the right side, and finally the node. Used for: Deleting nodes.</li>
                <li><strong>Level-Order (BFS):</strong> Visit nodes level by level from the root. Used for: Finding the shortest path in simple trees.</li>
            </ul>
            <p><strong>Graph Traversals (Ways to visit nodes in a graph):</strong></p>
            <ul>
                <li><strong>DFS (Depth-First Search):</strong> Start at one node, go as deep as possible, and backtrack when needed. Used for: Solving mazes, finding connected components.</li>
                <li><strong>BFS (Breadth-First Search):</strong> Visit neighbors first, then their neighbors, and so on. Used for: Finding the shortest path in simple graphs, like finding the shortest route on a map.</li>
            </ul>
            <p><strong>Applications:</strong></p>
            <ul>
                <li><strong>Tree Applications:</strong></li>
                <ul>
                    <li>File System: Organizing folders and files.</li>
                    <li>Binary Search Tree (BST): Efficiently finding data in databases.</li>
                    <li>Decision Trees: Used in making decisions, like in machine learning.</li>
                </ul>
                <li><strong>Graph Applications:</strong></li>
                <ul>
                    <li>Social Networks: Connections between people (friends, followers).</li>
                    <li>Maps/Navigation: Finding the shortest route between cities or locations.</li>
                    <li>Web Crawlers: Searching the internet by following links between websites.</li>
                </ul>
            </ul>
        </section>

        <section>
    <h4>7. Deliberate on Sorting and Searching Algorithms, the Technique Behind Each, and How They Connect to the Real World</h4>

    <p><strong>Sorting Algorithms</strong></p>
    
    <ul>
        <li><strong>Bubble Sort:</strong>
            <p><strong>How it works:</strong> Compares adjacent items and swaps them if they‚Äôre out of order. Repeats until the list is sorted.</p>
            <p><strong>Real-world example:</strong> Sorting a deck of cards by comparing two cards at a time and swapping them.</p>
            <p><strong>Use:</strong> Best for small datasets, inefficient for large ones.</p>
        </li>
        <li><strong>Selection Sort:</strong>
            <p><strong>How it works:</strong> Finds the smallest item, moves it to the front, and repeats for the rest of the list.</p>
            <p><strong>Real-world example:</strong> Organizing books by picking the shortest book first.</p>
            <p><strong>Use:</strong> Useful when minimizing swaps, but not the fastest for large datasets.</p>
        </li>
        <li><strong>Insertion Sort:</strong>
            <p><strong>How it works:</strong> Builds a sorted list one item at a time by inserting each item in its correct position.</p>
            <p><strong>Real-world example:</strong> Sorting a deck of cards by picking and placing cards in the right order.</p>
            <p><strong>Use:</strong> Great for small or nearly sorted datasets.</p>
        </li>
        <li><strong>Merge Sort:</strong>
            <p><strong>How it works:</strong> Splits the list, sorts each part, and merges them back together.</p>
            <p><strong>Real-world example:</strong> Sorting papers by dividing them into smaller stacks, sorting, and combining them.</p>
            <p><strong>Use:</strong> Ideal for large datasets and external sorting.</p>
        </li>
        <li><strong>Quick Sort:</strong>
            <p><strong>How it works:</strong> Picks a pivot, places smaller elements on one side, larger ones on the other, and repeats.</p>
            <p><strong>Real-world example:</strong> Dividing a group by height into smaller groups and sorting each.</p>
            <p><strong>Use:</strong> Fast for large datasets, but pivot choice matters.</p>
        </li>
        <li><strong>Heap Sort:</strong>
            <p><strong>How it works:</strong> Builds a heap and repeatedly extracts the largest or smallest element for the sorted list.</p>
            <p><strong>Real-world example:</strong> Priority queue where highest-priority items are handled first.</p>
            <p><strong>Use:</strong> Efficient for priority queues and structured sorting.</p>
        </li>
    </ul>
    
    <p><strong>Searching Algorithms</strong></p>
    <ul>
        <li><strong>Linear Search:</strong>
            <p><strong>How it works:</strong> Checks each item one by one until the target is found.</p>
            <p><strong>Real-world example:</strong> Searching for a name in a phone book sequentially.</p>
            <p><strong>Use:</strong> Simple but slow for large datasets.</p>
        </li>
        <li><strong>Binary Search:</strong>
            <p><strong>How it works:</strong> Works on sorted lists, checks the middle, and narrows the search range by half each time.</p>
            <p><strong>Real-world example:</strong> Finding a word in a dictionary by dividing the search range.</p>
            <p><strong>Use:</strong> Very efficient for sorted lists.</p>
        </li>
        <li><strong>Breadth-First Search (BFS):</strong>
            <p><strong>How it works:</strong> Explores all nodes at the current level before moving to the next.</p>
            <p><strong>Real-world example:</strong> Exploring all rooms on one floor of a building before moving to the next floor.</p>
            <p><strong>Use:</strong> Best for finding the shortest path in unweighted graphs.</p>
        </li>
        <li><strong>Depth-First Search (DFS):</strong>
            <p><strong>How it works:</strong> Goes as deep as possible along one path before backtracking and trying another.</p>
            <p><strong>Real-world example:</strong> Exploring a maze by going deep down one path until a dead end.</p>
            <p><strong>Use:</strong> Useful for exploring all paths or solutions in puzzles and games.</p>
        </li>
    </ul>

    <p><strong>Real World Connections</strong></p>
    <ul>
        <li><strong>Sorting:</strong> Used in organizing files, arranging products, or sorting cards.</li>
        <li><strong>Searching:</strong> Essential for finding contacts, books, or other data.</li>
        <li><strong>BFS:</strong> Helps in GPS systems to find the shortest routes and in social networks to find connections.</li>
        <li><strong>DFS:</strong> Useful for puzzle-solving and exploring all possible moves in games.</li>
    </ul>
</section>


       <section>
    <h4>8. Discuss the Importance of Graph Algorithms with Respect to Spanning Trees and Shortest Paths</h4>
    
    <p><strong>Dijkstra's Algorithm</strong></p>
    <ul>
        <li><strong>Purpose:</strong> Finds the shortest path from a source node to all other nodes.</li>
        <li><strong>Type:</strong> Single-source shortest path algorithm.</li>
        <li><strong>Use:</strong> Best for weighted graphs with non-negative weights.</li>
    </ul>

    <p><strong>Floyd-Warshall Algorithm</strong></p>
    <ul>
        <li><strong>Purpose:</strong> Calculates shortest paths between all pairs of nodes.</li>
        <li><strong>Type:</strong> All-pairs shortest path algorithm.</li>
        <li><strong>Use:</strong> Suitable for dense graphs.</li>
    </ul>

    <p><strong>Prim's Algorithm</strong></p>
    <ul>
        <li><strong>Purpose:</strong> Finds the Minimum Spanning Tree (MST) of a graph.</li>
        <li><strong>Type:</strong> Greedy algorithm.</li>
        <li><strong>Use:</strong> Ideal for network design and minimizing total connection cost.</li>
    </ul>

    <p><strong>Shortest Path</strong></p>
    <ul>
        <li><strong>Purpose:</strong> Finds the minimum path between nodes.</li>
        <li><strong>Examples:</strong> Dijkstra‚Äôs, Bellman-Ford algorithms.</li>
        <li><strong>Use:</strong> Navigation systems and network optimization.</li>
    </ul>

    <p><strong>Spanning Trees</strong></p>
    <ul>
        <li><strong>Purpose:</strong> Optimizes network design by connecting all nodes with minimal edges.</li>
        <li><strong>Examples:</strong> Prim‚Äôs, Kruskal‚Äôs algorithms.</li>
        <li><strong>Use:</strong> Efficient for designing layouts like electrical grids or road networks.</li>
    </ul>
</section>
            
        <section>
    <h4>9. Discuss the Different Studied Algorithm Design Techniques</h4>
    
    <p><strong>Algorithm Design Techniques</strong></p>
    <ul>
        <li><strong>Brute Force:</strong> Solve problems by trying all possible solutions, guaranteed to find the correct one but inefficient for large inputs.</li>
        <li><strong>Divide and Conquer:</strong> Break a problem into smaller subproblems, solve them recursively, and combine results (e.g., Merge Sort).</li>
        <li><strong>Decrease and Conquer:</strong> Reduce the problem size by solving a smaller instance of the problem and building up to the solution (e.g., Insertion Sort).</li>
        <li><strong>Transform and Conquer:</strong> Transform the problem into an easier form and solve it more efficiently (e.g., Binary Search).</li>
        <li><strong>Greedy Algorithm:</strong> Make the locally optimal choice at each step, hoping it leads to the global optimum (e.g., Huffman Coding).</li>
    </ul>

     <p><strong>Algorithms</strong></p>

    <ul>
        <li><strong>Boyer-Moore Algorithm:</strong> A string searching algorithm that efficiently finds a substring within a text by skipping sections of the text.</li>
        <li><strong>Rabin-Karp Algorithm:</strong> Uses hashing to find a substring in a string, efficient for multiple pattern searches.</li>
        <li><strong>Dijkstra‚Äôs Algorithm:</strong> Finds the shortest path between two nodes in a weighted graph by iteratively selecting the closest node.</li>
        <li><strong>Floyd-Warshall Algorithm:</strong> Finds the shortest paths between all pairs of nodes in a weighted graph, using dynamic programming.</li>
        <li><strong>Kruskal‚Äôs Algorithm:</strong> Finds the Minimum Spanning Tree (MST) by sorting edges and connecting nodes with the smallest weights without forming cycles.</li>
        <li><strong>Prim‚Äôs Algorithm:</strong> Finds the MST by growing a tree one edge at a time, always selecting the smallest edge that connects a node to the tree.</li>
        <li><strong>Warshall‚Äôs Algorithm:</strong> Computes the transitive closure of a directed graph, determining reachability between all pairs of vertices.</li>
    </ul>

    <p><strong>Reflection on Algorithm Design Techniques</strong></p>
    <p>There are several key algorithm design techniques, each serving different problem-solving needs. Backtracking explores all possible solutions and discards those that don‚Äôt work, useful for problems like N-Queens or Sudoku. Divide and conquer splits a problem into smaller sub-problems, solves them individually, and then combines the results, as seen in merge sort and quick sort. Brute force relies on trying every possible solution to find the correct one, used in algorithms like the Rabin-Karp algorithm for string matching. Graph algorithms like Dijkstra‚Äôs and Floyd-Warshall help find the shortest path in graphs, while Kruskal‚Äôs algorithm is used for finding the minimum spanning tree.</p>
</section>

</section>
<h1>Business Cases Implementation</h1>
    <h2>Business Case: Student Admission Management</h2>
    <p>Implementation by using <strong>Hash Tables</strong>, <strong>Priority Queue</strong> (Min-heap or Max-heap), and <strong>Graphs</strong> (Dijkstra's Algorithm).</p>
    
    <div class="section">
        <h3>1. Hash Table</h3>
        <p><strong>Use Case:</strong> Efficiently store and retrieve student records.</p>
        <p><strong>Example Implementation:</strong></p>
        <ul>
            <li><strong>Key:</strong> Student ID or unique application number.</li>
            <li><strong>Value:</strong> Details like name, scores, preferences, and status.</li>
        </ul>
        <p><strong>Advantages:</strong></p>
        <ul>
            <li>Fast lookups for student data (<code>O(1)</code> on average).</li>
            <li>Easily update records during the admission process.</li>
        </ul>
    </div>

    <div class="section">
        <h3>2. Priority Queue</h3>
        <p><strong>Use Case:</strong> Process applications based on priority (e.g., merit, reservation, or first-come-first-serve).</p>
        <p><strong>Example Implementation:</strong></p>
        <ul>
            <li><strong>Priority:</strong> Merit scores or time of application.</li>
            <li><strong>Data Structure:</strong> Min-heap or Max-heap.</li>
        </ul>
        <p><strong>Advantages:</strong></p>
        <ul>
            <li>Guarantees the highest-priority application is processed first.</li>
            <li>Efficient insertion and extraction (<code>O(log n)</code>).</li>
        </ul>
    </div>

    <div class="section">
        <h3>3. Graphs (Dijkstra's Algorithm)</h3>
        <p><strong>Use Case:</strong> Seat allocation based on preferences and availability.</p>
        <p><strong>Example Implementation:</strong></p>
        <ul>
            <li>Represent students and institutions as nodes.</li>
            <li>Connect a student node to preferred institutions with edges.</li>
            <li>Weight the edges based on preference rankings or eligibility criteria.</li>
        </ul>
        <p><strong>Algorithm:</strong></p>
        <p><strong>Dijkstra's Algorithm</strong> is the most intuitive and relevant for:</p>
        <ul>
            <li><strong>Finding the Best Match:</strong> Quickly identifies the best institution for a student based on weighted preferences (e.g., proximity, scores).</li>
            <li><strong>Scalability:</strong> Handles large datasets efficiently with priority queues.</li>
        </ul>
</section>

    </div>
</body>
</html>
